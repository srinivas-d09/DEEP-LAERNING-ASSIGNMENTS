{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [],
   "source": [
    "class gates():\n",
    "    def __init__(self, not_weight = np.array([1]), and_weight = np.array([-1,1])\n",
    "                , or_weight = np.array([1,-4]), or_biase = 1, and_biase = -7, not_biase = .1,\n",
    "                learning_rate = .1) -> None:\n",
    "        self.not_weight = not_weight\n",
    "        self.and_weight = and_weight\n",
    "        self.or_weight = or_weight\n",
    "        self.or_biase = or_biase\n",
    "        self.and_biase = and_biase\n",
    "        self.not_biase = not_biase\n",
    "        self.learning_rate = learning_rate\n",
    "\n",
    "    def activation(self,x):\n",
    "        return 1 if x>=0 else 0\n",
    "    \n",
    "    def perseptron(self,x,w,b):\n",
    "        res = np.dot(x,w) + b\n",
    "        return self.activation(res)\n",
    "    \n",
    "    def NOT_function(self,x):\n",
    "        x = np.array(x)\n",
    "        return self.perseptron(x,self.not_weight,self.not_biase)\n",
    "    \n",
    "    def AND_function(self,x):\n",
    "        x = np.array(x)\n",
    "        return self.perseptron(x,self.and_weight,self.and_biase)\n",
    "    \n",
    "    def OR_function(self,x):\n",
    "        x = np.array(x)\n",
    "        return self.perseptron(x,self.or_weight,self.or_biase)\n",
    "    \n",
    "    def XOR_function(self,x):\n",
    "        x = np.array(x)\n",
    "        \n",
    "        y0 = self.NOT_function(x[0])\n",
    "        y1 = self.NOT_function(x[1])\n",
    "        z1 = self.AND_function([y0,x[1]])\n",
    "        z2 = self.AND_function([y1,x[0]])\n",
    "        \n",
    "        return self.OR_function([z1,z2])\n",
    "    \n",
    "    def NXOR_function(self,x):\n",
    "        return self.NOT_function(self.XOR_function(x))\n",
    "    \n",
    "    def update_weight(self,inp,out,tar,weight):\n",
    "        res = weight + self.learning_rate*(tar - out)*inp\n",
    "        return res\n",
    "    \n",
    "    def update_biase(self,b,out,tar,):\n",
    "        res = b + 0.3*(tar - out)\n",
    "        return res\n",
    "\n",
    "    def update_not(self):\n",
    "        inp = np.array([1,0])\n",
    "        tar = np.array([0,1])\n",
    "        \n",
    "        i = 0\n",
    "        while i <len(inp):\n",
    "            out = self.NOT_function(inp[i])\n",
    "            if(tar[i] != out):\n",
    "                weight = self.not_weight\n",
    "                self.not_weight = self.update_weight(inp[i],out,tar[i],self.not_weight)\n",
    "                if (weight == self.not_weight).all():\n",
    "                    self.not_biase = self.update_biase(self.not_biase,out,tar[i])\n",
    "                print(self.not_weight,self.not_biase)\n",
    "                i = 0\n",
    "            else:\n",
    "                i += 1\n",
    "                \n",
    "    def update_and(self):\n",
    "        inp = np.array([(0,0),(1,0),(0,1),(1,1)])\n",
    "        tar = np.array([0,0,0,1])\n",
    "        \n",
    "        i = 0\n",
    "        while i <len(inp):\n",
    "            out = self.AND_function(inp[i])\n",
    "            if(tar[i] != out):\n",
    "                weight = self.and_weight\n",
    "                self.and_weight = self.update_weight(inp[i],out,tar[i],self.and_weight)\n",
    "                if (weight == self.and_weight).all():\n",
    "                    self.and_biase = self.update_biase(self.and_biase,out,tar[i])\n",
    "                print(self.and_weight,self.and_biase)\n",
    "                i = 0\n",
    "            else:\n",
    "                i += 1\n",
    "                \n",
    "    def update_or(self):\n",
    "        inp = np.array([(0,0),(1,0),(0,1),(1,1)])\n",
    "        tar = np.array([0,1,1,1])\n",
    "        \n",
    "        i = 0\n",
    "        while i <len(inp):\n",
    "            out = self.OR_function(inp[i])\n",
    "            if(tar[i] != out):\n",
    "                weight = self.or_weight\n",
    "                self.or_weight = self.update_weight(inp[i],out,tar[i],self.or_weight)\n",
    "                if (weight == self.or_weight).all():\n",
    "                    self.or_biase = self.update_biase(self.or_biase,out,tar[i])\n",
    "                print(self.or_weight,self.or_biase)\n",
    "                i = 0\n",
    "            else:\n",
    "                i += 1\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "a = gates(\n",
    "    not_weight=2,\n",
    "    not_biase=-5,\n",
    "    learning_rate=.4\n",
    ")\n",
    "\n",
    "a.update_and()\n",
    "a.update_not()\n",
    "a.update_or()\n",
    "# print(a.not_weight,a.not_biase)\n",
    "print(a.NOT_function(0),a.NOT_function(1))\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.1"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
